% !tex encoding = utf-8 unicode

% this is a simple template for a latex document using the "article" class.
% see "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage{fullpage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% packages
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}
\usepackage{authblk}
\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
\usepackage{bold-extra}    
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.
    
    
    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
%     \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}
   
\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm,calligra}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
% \usepackage{bickham}
\usepackage{hyperref}
\usepackage{cryptocode}
\usepackage{framed} 
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent
    
    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}

\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
  
    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
    
    
    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)
    
    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!
\usepackage[scr=esstix]  % heavily sloped
%             cal=esstix]   % slightly sloped
           {mathalpha}
 %%% end article customizations
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % macros
 \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\plonk}{\ensuremath{\mathcal{P} \mathfrak{lon}\mathcal{K}}\xspace}
\newcommand{\cq}{\ensuremath{\mathpgoth{cq} }\xspace}
\newcommand{\cqlin}{\ensuremath{\mathpgoth{cq}\mathscr{\text{\calligra{lin}}} }\xspace}
\newcommand{\cqstar}{\ensuremath{\mathpgoth{cq^{\mathbf{*}} }}\xspace}
\newcommand{\protogal}{{\scshape Proto\bfseries{galaxy}}\xspace}
\newcommand{\stackproofs}{s{\ensuremath{\mathfrak{t} \mathpgoth {ack}}\bfseries{proofs}}\xspace}
\newcommand{\protostar}{{\scshape Protostar}\xspace}
\newcommand{\hypernova}{{HyperNova}\xspace}
\newcommand{\flookup}{\ensuremath{\mathsf{\mathpgoth{Flookup}}}\xspace}
\newcommand{\baloo}{\ensuremath{\mathrm{ba}\mathit{loo}}\xspace}
\newcommand{\caulkp}{\ensuremath{\mathsf{\mathrel{Caulk}\mathrel{\scriptstyle{+}}}}\xspace}
\newcommand{\caulk}{\ensuremath{\mathsf{Caulk}}\xspace}
\newcommand{\plookup}{\ensuremath{\mathpgoth{plookup}}\xspace}
\newcommand{\tablegroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\V}{\ensuremath{\mathbf{V} }\xspace}
\newcommand{\relbase}{\ensuremath{\rel_0}\xspace}

\newcommand{\instbase}{\ensuremath{\inst_0}\xspace}
\newcommand{\witbase}{\ensuremath{\wit_0}\xspace}


\newcommand{\papertitle}{\stackproofs: Private proofs of stack and contract execution using \protogal}
%\newcommand{\authorname}}
\newcommand{\company}{}
\title{ \papertitle \\[0.72cm]}
\author{}
% \author{ Liam Eagen \\ \tt{Blockstream Research}\\ \tt{Zeta Function Technologies}   \and Ariel Gabizon \\ \tt{Zeta Function Technologies} } 
% \author[1]{Liam Eagen}
% \author[1]{Ariel Gabizon}
% \author{2}{Patrick Towa}
% \author{2}{Zac Williamson}
% \affil[1]{Zeta Function Technologies}
% \affil[1]{Zeta Function Technologies}
% \affil[2]{Aztec Labs}
% 
% 	\large{\authorname} \\[0.5cm] \large{\company}
% 	\\ {DRAFT}
%}
%\date{} % activate to display a given date or no date (if empty),

% otherwise the current date is printed 
\DeclareMathAlphabet{\mathpgoth}{OT1}{pgoth}{m}{n}	
\ProvidesPackage{numdef}



%% Ariel Macros:
% \num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

% \num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}
\newcommand{\alg}{\ensuremath{\mathscr{A}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}
\newcommand{\chalpoint}{\ensuremath{\mathfrak{z}}\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{\left(#1\right)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
% \num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
% \num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\newcommand{\srs}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\regsrs}[1]{\ensuremath{\sett{\enc1{x^i}}{i\in \set{0,\ldots,#1-1}}}\xspace}
\newcommand{\srsm}{\ensuremath{\mathsf{srs}_M}\xspace}
\newcommand{\srsext}{\ensuremath{\mathsf{srs^*}}\xspace}
\newcommand{\srsbase}{\ensuremath{\mathsf{srs_0}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
% \newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
% \newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
% \newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\ensuremath{\mathsf{reject}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{accept}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\enc1{#1(x)}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\B}{\ensuremath{\set{0,1}}\xspace}
\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
 \newcommand{\partition}{\ensuremath{{\mathcal T}}\xspace}
 \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\hash}{\ensuremath{\mathcal{H}}\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
% \newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\hgen}{\ensuremath{\omega}\xspace}
\newcommand{\gops}{\G1-operations\xspace}
\newcommand{\nlogngops}{$O(n\log n)$ \G1-operations\xspace}
\newcommand{\nlognfops}{$O(n\log n)$ \F-operations\xspace}
\newcommand{\fops}{\F-operations\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\mathsf{\pi}}\xspace}
\newcommand{\prfone}{\ensuremath{\mathsf{\pi_1}}\xspace}
% \newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\newinst}{\ensuremath{\phi^*}\xspace}
\newcommand{\row}{\ensuremath{\mathsf{R}}\xspace}
\newcommand{\col}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\mathsf{\omega}}\xspace}
\newcommand{\eps}{\ensuremath{\epsilon}\xspace}
\newcommand{\inpF}{\ensuremath{\mathscr{x}}\xspace}
\newcommand{\witF}{\ensuremath{\mathscr{w}}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\verpg}{\ensuremath{\ver_{PG}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\perpg}{\ensuremath{\per_{PG}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\relrand}{\ensuremath{\mathcal{R^{\mathsf{rand}}}}\xspace}
\newcommand{\lang}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
% \newcommand{\hgen}{\ensuremath{\mathbf{\omega}}\xspace}
\newcommand{\vgen}{\ensuremath{\mathbf{g}}\xspace}
% \renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathscr R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\polysofdegeq}[1]{\ensuremath{\F_{\leq #1}[X]}\xspace}
 \newcommand{\pols}{\ensuremath{\F[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\protstar}{\ensuremath{\mathscr{P}^*}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}

	
\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i\in[#1]}}
\newcommand{\sumzertok}[1]{\sum_{#1=0}^{k}}
\newcommand{\sumpoly}[1]{\sum_{i=0}^{#1-1}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j\in[#1]}}
\newcommand{\ZeroH}{\ensuremath{Z_{H}} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}
    

\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{S}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\prv}%{\Prove{\snark}}
\newcommand{\Vsnark}{\ver}%{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
\newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\prob}{\ensuremath{\mathrm{Pr}}\xspace}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\transcript}{\ensuremath{\mathsf{transcript}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{ {\prot}_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
% \newcommand{\Rsnark}{\R{\snark}}
\newcommand{\Rsnark}{\R}
\newcommand{\subvec}[1]{\ensuremath{#1|_{\subspace}}\xspace}
\newcommand{\restricttovec}[1]{\ensuremath{#1|_{\subgroup}}\xspace}
\newcommand{\isinvanishing}[1]{\ensuremath{\mathsf{IsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\batchedisinvanishing}[1]{\ensuremath{\mathsf{BatchedIsInVanishing_{\subspace,#1}}}\xspace}
\newcommand{\isconsistent}{\ensuremath{\mathsf{IsConsistent}}\xspace}
\newcommand{\isintable}{\ensuremath{\mathsf{IsInTable}}\xspace}
\newcommand{\lincheck}{\ensuremath{\mathsf {lincheck}}\xspace}
\newcommand{\accprot}{\ensuremath{\mathsf {accProt}}\xspace}
\newcommand{\isinvanishingtable}[1]{\ensuremath{\mathsf{IsInVanishingTable_{\subspace,#1}}}\xspace}
\newcommand{\isvanishingsubtable}[1]{\ensuremath{\mathsf{IsVanishingSubtable_{#1}}}\xspace}
\newcommand{\haslowerdegree}{\ensuremath{\mathsf{HasLowerDegree}}\xspace}
\newcommand{\haslowdegree}[1]{\ensuremath{\mathsf{HasLowDegree_{#1}}}\xspace}
\newcommand{\issubtable}[1]{\ensuremath{\mathsf{IsSubtable_{#1}}}\xspace}
\newcommand{\isinsubtable}[2]{\ensuremath{\mathsf{IsInSubtable_{#1,#2}}}\xspace}
\newcommand{\secbasezero}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbase}[1]{\ensuremath{\hat{\tau}_{#1}}\xspace}
\newcommand{\secbasereg}[1]{\ensuremath{\tau_{#1}}\xspace}
\newcommand{\secset}{\ensuremath{I}\xspace}
\newcommand{\pubbase}[1]{\ensuremath{\mu_{#1}}\xspace}
\newcommand{\subspace}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\subgroup}{\ensuremath{\mathbb{H}}\xspace}
\newcommand{\biggroup}{\ensuremath{\mathbb{V}}\xspace}
\newcommand{\subtable}{\ensuremath{T_0}\xspace}
\newcommand{\tablelang}{\ensuremath{\lang_{T}}\xspace}
\newcommand{\vanishingtablelang}{\ensuremath{\lang_{\subspace}}\xspace}
\newcommand{\nonorm}[1]{\ensuremath{\Gamma^T_{#1}}\xspace}
\newcommand{\unnorm}[2]{\ensuremath{\Gamma^{#1}_{#2}}\xspace}
\newcommand{\bigspacebase}{\ensuremath{\lambda}\xspace}
\newcommand{\bigspacegen}{\ensuremath{\mathsf{h}}\xspace}
\newcommand{\modvan}[1]{\ensuremath{\mathrm{mod\;}Z_{#1}}\xspace}
\newcommand{\extractevaltable}{\ensuremath{\mathsf{ExtractEvalTable}_{C,\tablegroup}}\xspace}
\newcommand{\witsize}{\ensuremath{n}\xspace}
\newcommand{\witruntime}{\ensuremath{\witsize\log\witsize}\xspace}
\newcommand{\tabsize}{\ensuremath{N}\xspace}
\newcommand{\tabruntime}{\ensuremath{\tabsize\log\tabsize}\xspace}
\newcommand{\tab}{\ensuremath{\mathfrak{t}}\xspace}
 \renewcommand{\a}{\ensuremath{\mathsf{a}}\xspace}
\renewcommand{\b}{\ensuremath{\mathsf{b}_0}\xspace}
\renewcommand{\c}{\ensuremath{\mathsf{c}}\xspace}
\renewcommand{\r}{\ensuremath{\mathsf{r}}\xspace}
\newcommand{\f}{\ensuremath{\mathsf{f}}\xspace}
\renewcommand{\g}{\ensuremath{\mathsf{g}}\xspace}
\newcommand{\matrices}{\ensuremath{\F^{n\times n}}\xspace}
\newcommand{\ftwo}{\ensuremath{\mathsf{f}_2}\xspace}
\renewcommand{\p}{\ensuremath{\mathsf{p}}\xspace}
\newcommand{\q}{\ensuremath{\mathsf{q}}\xspace}
\newcommand{\qone}{\ensuremath{\mathsf{q_1}}\xspace}
\newcommand{\s}{\ensuremath{\mathsf{s}}\xspace}
\newcommand{\qa}{\ensuremath{\mathsf{q_a}}\xspace}
\newcommand{\qb}{\ensuremath{\mathsf{q_b}}\xspace}
\newcommand{\m}{\ensuremath{\mathsf{m}}\xspace}
\newcommand{\agam}{\ensuremath{a_\gamma}\xspace}
\newcommand{\gamproof}{\ensuremath{\mathsf{\pi_\gamma}}\xspace}
\newcommand{\zerproof}{\ensuremath{\mathsf{\a}_0}\xspace}
\newcommand{\bgam}{\ensuremath{b_\gamma}\xspace}
\newcommand{\bzergam}{\ensuremath{b_{0,\gamma}}\xspace}
\newcommand{\qbgam}{\ensuremath{Q_{b,\gamma}}\xspace}
\newcommand{\zgam}{\ensuremath{Z_{\bigspace,\gamma}}\xspace}
\newcommand{\betaa}{\ensuremath{\mathbf{\boldsymbol{\beta}}}\xspace}
\newcommand{\deltaa}{\ensuremath{\mathbf{\boldsymbol{\delta}}}\xspace}
\newcommand{\gammaa}{\ensuremath{\mathbf{\boldsymbol{\gamma}}}\xspace}
\newcommand{\witcom}{\ensuremath{\mathsf{W}}\xspace}
\newcommand{\instt}{\ensuremath{\Phi^*}\xspace}
\newcommand{\insttbase}{\ensuremath{\Phi}\xspace}
\newcommand{\pow}{\ensuremath{\mathsf{pow}}\xspace}
\newcommand{\eq}{\ensuremath{\mathsf{eq}}\xspace}
\newcommand{\FFT}{\ensuremath{\mathsf{FFT}}\xspace}
\newcommand{\fgam}{\ensuremath{f_{\gamma}}\xspace}
\newcommand{\pgam}{\ensuremath{P_{\gamma}}\xspace}
\newcommand{\supp}[1]{\ensuremath{\mathrm{supp}(#1)}\xspace}
\newcommand{\degoffset}{\ensuremath{\tabsize-1-(\witsize-2)}\xspace}
\newcommand{\modpoly}[1]{\ensuremath{\;\;\mod #1(X) }\xspace}
\newcommand{\coeff}[2]{\ensuremath{(#1)_{[#2]} }\xspace}
\newcommand{\kzg}[1]{\ensuremath{\mathsf{KZG}_{#1,\subgroup}}\xspace}
\newcommand{\accscheme}[2]{$(#1\mapsto #2)$-folding scheme\xspace}
\newcommand{\accrel}{\ensuremath{\rel_{\mathpgoth{acc}}}\xspace}
\newcommand{\relpair}{\ensuremath{\mathfrak{p}}\xspace}
\newcommand{\inststar}{\ensuremath{\inst^*}\xspace}
\newcommand{\witstar}{\ensuremath{\wit^*}\xspace}
\newcommand{\relpairstar}{\ensuremath{\relpair^*}\xspace}
\newcommand{\witt}{\ensuremath{\mathrm{w}}\xspace}
\newcommand{\nodelabel}{\ensuremath{\mathfrak{n}}\xspace}
\newcommand{\roundnum}{\ensuremath{\mathpgoth{k}}\xspace}
\newcommand{\manyvar}{\ensuremath{\mathfrak{J}}\xspace}
\newcommand{\nmin}{\ensuremath{[n]_0}\xspace}
\newcommand{\zfin}{\ensuremath{z_{\mathscr{final}}}\xspace}
\newcommand{\relapp}{\ensuremath{\rel_{app}}\xspace}
\newcommand{\relexec}{\ensuremath{\rel_{\mathrm{exec}}}\xspace}
\newcommand{\relF}{\ensuremath{\rel_{F}}\xspace}
\newcommand{\init}{\ensuremath{\mathsf{init}}\xspace}
\newcommand{\add}{\ensuremath{\mathsf{add}}\xspace}
\newcommand{\del}{\ensuremath{\mathsf{del}}\xspace}
\renewcommand{\read}{\ensuremath{\mathsf{read}}\xspace}
\newcommand{\countrange}{\ensuremath{[n]}\xspace}
\newcommand{\true}{\ensuremath{\mathsf{true}}\xspace}
\newcommand{\false}{\ensuremath{\mathsf{false}}\xspace}
\newcommand{\finstate}{\ensuremath{V}\xspace}
\newcommand{\ops}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\op}{\ensuremath{\mathscr{op}}\xspace}
\newcommand{\instapp}{\ensuremath{\mathfrak{x}}\xspace}
\newcommand{\witapp}{\ensuremath{\mathfrak{w}}\xspace}
\newcommand{\instnoops}{\ensuremath{\mathbf{x}}\xspace}
 \renewcommand{\path}{\ensuremath{\mathbf{p}}\xspace}
\renewcommand{\root}{\ensuremath{\mathbf{r}}\xspace}
\newcommand{\cmtwo}{\ensuremath{\cm^{\oplus{2}}}\xspace}
\newcommand{\predinst}{\ensuremath{\mathpgoth{f}}\xspace}
\renewcommand{\empty}{\ensuremath{g_{\mathscr{empty}}}\xspace}
\newcommand{\funcs}{\ensuremath{\mathrm{F}}\xspace}
\newcommand{\ztafuncs}{\ensuremath{\mathcal{D}}\xspace}
% \newcommand{\instF}{\ensuremath{\mathrm{x}}\xspace}
% \newcommand{\witF}{\ensuremath{\mathrm{w}}\xspace}
\newcommand{\instexec}{\ensuremath{\mathrm{x_{exec}}}\xspace}
\newcommand{\witexec}{\ensuremath{\mathrm{w_{exec}}}\xspace}
\newcommand{\witf}{\ensuremath{\mathsf{w_f}}\xspace}
\newcommand{\sel}{\ensuremath{\mathsf{q}}\xspace}
% \newcommand{\perm}{\ensuremath{\mathsf{s}}\xspace}
\newcommand{\args}{\ensuremath{\mathsf{args}}\xspace}
\newcommand{\callnum}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\recset}{\ensuremath{\mathsf{V}}\xspace}
\newcommand{\tree}{\ensuremath{\mathsf{T}}\xspace}
\newcommand{\node}{\ensuremath{\mathsf{n}}\xspace}
\newcommand{\incsum}{\ensuremath{\text{\calligra{s}}}\xspace}
\newcommand{\inchash}{\ensuremath{\mathscr{h}}\xspace}
\newcommand{\finpred}{\ensuremath{\mathsf{f}}\xspace}
\newcommand{\zksnark}{zk-SNARK\;}
\begin{document}
    \maketitle
\begin{abstract}
The goal of this note is to describe and analyze a simplified variant of the zk-SNARK construction used in the Aztec protocol.
Taking inspiration from the popular notion of Incrementally Verifiable Computation\cite{ivc} (IVC)
we define a related notion of \emph{Repeated Computation with Global state} (RCG). As opposed to IVC, in RCG we assume the computation terminates before proving starts, and in addition to the local transitions some global consistency checks of the whole computation are allowed. However, we require the space efficiency of the prover to be close to that of an IVC prover not required to prove this global consistency.
We show how RCG is useful for desigining a proof system for a private smart contract system like Aztec.
\end{abstract}
\section{Introduction}
Incrementally Verifiable Computation (IVC) \cite{ivc} and its generalization to Proof Carrying Data (PCD) \cite{pcd} are useful tools for constructing space-efficient SNARK provers.
In IVC and PCD we always have an acyclic computation.
However code written in almost any programming language \emph{is} cyclic in the sense of often relying on internal calls - 
we start from a function $A$, execute some commands, go into a function $B$, execute its commands, and go back to $A$.
When making a SNARK proof of such an execution, we typically linearize or ``flatten'' the cycle stemming from  the internal call, in one of the following two ways
\begin{enumerate}
 \item The monolithic circuit approach - we ``inline'' all internal calls (as well as loops) into one long program without jumps.
 \item The VM approach - assume the code of $A,B$ is written in some prespecified instruction set. The program is executed by initially writing the code of $A,B$ into memory, and loading from memory and executing at each step the appropriate instruction according to a program counter. For example, the call to $B$ is made by changing the counter to that of the  first instruction of $B$. To prove correctness of the execution, all we need is a SNARK for proving correctness of a certain number of steps of a machine with this instruction set, and some initial memory state.
\end{enumerate}

The second approach is more generic, while the first offers more room for optimization, so we'd want to use it in resource-constrained settings, e.g. client-side proving.


However, what if we're in a situation where $A$ and $B$ have already been ``SNARKified'' separately?
Namely, there is a verification key attached to each one, and we are expected to use these keys specifically.
This is what happens in the Aztec system.
\paragraph{The Aztec private contract system:}
 Similar to Ethereum - we have contracts; and the contracts have functions.
A function in a contract can internally call a different function in the same or a different contract. Moreover, while writing the code for the different functions,
we can't predict specifically what function will be internally called by a given contract function. For example, a ``send token'' function could have an internal call to an ``authorize'' function.
But ``authorize'' is not tied to one specific verification key - as different token holders are allowed to set their own ``authorize'' function.


The goal of the Aztec system is to enable constructing zero-knowledge proofs of such contract function executions.
For this purpose, a contract is deployed by 
\begin{enumerate}
\item  Computing a verification key for each function of the contract.
\item Adding a commitment to the verification keys of the contract in a global ``function tree''. More accurately, a leaf of this tree is a hash of the
contract address with a merkle root of a tree whose leaves are the verification keys of that contract's functions.

\end{enumerate}

\paragraph{Dealing with Global state}
While running, a contract can read, add or delete notes belonging to it.
We can thus think of the notes as global variables shared between the different functions.




Let us think of all functions in this system as having multiple arguments, and returning \acc or \rej. (We can always move the output into the arguments if a function is not of this form.)
Here's a natural way to prove the mentioned execution: Put the arguments to $B$ in the public inputs of both the circuits of $A$ and $B$.
Verify the proofs $\prf_A,\prf_B$ for $A,B$; and check via the public inputs the same value was used in both proofs for the arguments of $B$.

However, this doesn't yet deal with the notes. During native execution, note operations happened at a certain order.
We can think of these operations as having timestamps incremented by one with each operation.
We need to check, for example, that if a note was read in a certain timestamp, it was indeed created
in an earlier timestamp.
We can have the note operations - \set{add, read, delete} - performed by a function be included in the public inputs of its circuit.
The issue is, what if $A$ is reading a note that was added in the internal call to $B$?
Checking the existence of an $add$ operation with smaller timestamp requires a constraint between the inputs of both circuits; and for an execution consisting of more calls, this constraint can involve any two circuits in the call tree.
% Describing the issue more generally, since we are forced to prove things in a different order than they were executed, we must enforce a global consistency between the witnesses of all iterations.

This brings us to the notion of \emph{Repeated Computation with Global state} (RCG). In RCG we have a transition predicate taking us from one state to the next. We wish to prove we know a sequence of witnesses taking us from a legal initial state to a certain publicly known final state. This might remind the reader of the popular notion of \emph{incrementally verifiable computation} (IVC). There are two differences.

\begin{itemize}
 \item 
In RCG we are not interested in ``incremental'' proofs of one step, only in proofs for a whole
sequence of transitions ending in a desired final state.

\item In RCG we allow a \emph{final predicate} checking a joint consistency condition between witnesses from all iterations.

\end{itemize}
 One could ask, why not \emph{only} have a final predicate that includes the transition checks? 
The point is that in our usecase the final predicate is applied to small parts of each iteration's witness - namely the note operations. As a result, the decomposition into a transition and final predicate can facilitate obtaining better prover efficiency, especially in terms of prover space.
Roughly, we'll require space sufficient for storing the inputs to the final predicate, in addition to the space required to prove a single transition.

\subsection{Related work}
mangrove, nexus, Jens's talk.



\section{Preliminaries}
\subsection{Terminology and Conventions}\label{sec:terminology}
We assume our field \F is of prime order.
We denote by \polysofdeg{d} the set of univariate polynomials over \F of degree smaller than d. 
We assume all algorithms described receive as an implicit parameter the security parameter $\lambda$.
Similarly, we assume all integer parameters in the paper are implicitly functions of $\lambda$.

Whenever we use the term \emph{efficient}, we mean an algorithm running in time \poly. Furthermore,
we assume an \emph{object generator} \obgen that is run with input $\lambda$ before all protocols, and returns all fields and groups used. Specifically, in our protocol $\obgen(\lambda) = (\F, \G,g)$ where
\begin{itemize}
\item \F is a prime field of super-polynomial size $r = \lambda^{\omega(1)}$
.
\item $\G$ is a group of size $r$.
\item $g$ is a uniformly chosen generator of \G.
\end{itemize}
We usually let the $\lambda$ parameter be implicit, i.e.\ write \F instead of $\F(\lambda)$.
We write \G additively.
% We use the notations $\enc1{x}\defeq x\cdot g_1$ and $\enc2{x}\defeq x\cdot g_2$.

We often denote by $[n]$ the integers \set{1,\ldots,n}.
% For example, when we refer below to the field $\F$, it is in fact a function $\F(\lambda)$ of $\lambda$, and part of
% the output of $\obgen(\lambda)$.
We use the acronym e.w.p. for ``except with probability''; i.e. e.w.p. $\gamma$ means with probability \emph{at least} $1-\gamma$.

% \paragraph{universal SRS-based public-coin protocols}
% We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the ``proof length'' of an interactive protocol. 
% 
% We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic \poly-time from an ``SRS of monomials'' of the form
% \sett{\enc1{x^i}}{a\leq i \leq b}, \sett{\enc2{x^i}}{c\leq i \leq d}, for uniform $x\in \F$,
% and some integers $a,b,c,d$ with absolute value bounded by \poly.
% It then follows from Bowe et al. \cite{SecondMPC} that the required SRS can be derived in a universal and updatable setup requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a \negl advantage in its probability of producing a proof of any statement.
% 
% For notational simplicity, we sometimes use the SRS \srs as an implicit parameter in protocols, and do not explicitly write it.
% 
% 

\paragraph{Representing \G}
Assume an injective function $R:\G \to \F^2$
Whenever we discuss $a\in \G$ we assume it is represented as  $R(a)$.
When we say for $b\in \F^2$ that $b\in \G$ we mean that there exists $a\in \G$ with $R(a)=b$.
\subsection{Relations of the app functions}
Define a relation including the selectors
Fixed polynomial $f(x_1,\ldots,x_{S})$
$S=n+d+\ell$
Relation \relapp of $\cm1,\ldots,\cm_S$

\section{The execution model:}
We present a formal framework that will be convenient for our proof system of what it means to prove an execution where functions can call each other, and there is global state.
For this, we first introduce record operations which is our specific notion of operating on a global state. 
\subsection{Record operations}
\emph{Records} are pairs $(v,c)$ - where $v\in \F$ is the \emph{value}, and $c\in \countrange$ is the \emph{counter}.
A \emph{record operation} has one of the following forms:
\begin{itemize}
 \item $(\add,v,c)$,
\item $(\del,v,vc,c)$,
\item $(\read,v,vc,c)$.

\end{itemize}
Here $v\in \F$ is a note value and $c,vc\in \countrange$ are counters.
$c$ is interpreted as the counter of the current operation, and $vc$ is interpreted as the counter of the operation where
the note was added in the case of a \read or \del operation.



We say a sequence \ops of record operations of size $n$ is \emph{consistent} if 
\begin{enumerate}
\item The counter values $c$ are distinct in all elements of \ops, and as a set equal to $\{1,\ldots,n\}$.
\item The $vc$ fields in all $\del$ operations $(\del,v,vc,c)\in \ops$ are distinct.
\item If $(v,\read,vc,c)\in \ops$, then $vc<c$ and $(\add, v,vc)\in \ops$.
\item If $(v,\del,vc,c)\in \ops$ then $vc<c$ and $(\add,v,vc)\in \ops$.
\end{enumerate}

Let \recset be set of records 
We say $\ops$ is \emph{has output \recset} if:
\begin{itemize}
 \item $\ops$ is consistent.
 \item $\recset=\set{(v,c) | (\add,v,c)\in \ops\;\&\; \forall c',(\del,v,c,c')\notin \ops }$. In words,
 $V$ is the set of notes that were added and not deleted.
\end{itemize}



\subsection{The plonkish relation}
Now we introduce a relation describing the individual function executions tailored to make it convenient in the next section to discuss an execution of a  sequence functions calling each other.
Some choices of constants - like the maximal number of inner calls being two, are abitrary.
We require the instance to adhere to a form containing both the record operations and the details of the inner calls (though they will be interpreted as such only in the next section when we discuss valid executions).

We fix a polynomial $G:\F^8\to \F$ that is an implicit parameter in the following definition of the relation \relapp.

\relapp consists of all pairs $(\instapp, \witapp)$ having the form 
\begin{itemize}
 \item 
$\instapp= (\f,\args,\callnum, \f_1,\args_1, \f_2,\args_2,\ops)$
where $\f,\f_1,\f_2 \in \G,\args\in \F^4,\callnum\in \set{0,1,2}$; 
\item $\witapp=(\witf,\wit)$
where 
\begin{itemize}
 \item 
$\witf=(\perm_1,\ldots,\perm_4,\sel_1,\ldots,\sel_4)$,where $\perm_j \in [|\instapp|+N]^n,\sel_j \in \F^n$ for each $j\in [4]$
\item $\wit\in \F^N$
\end{itemize}
\end{itemize}
such that
\begin{enumerate}
                                                                                
\item  Setting $x=(\instapp,\wit)$, for all $i\in [n]$
\[G(\sel_{1,i},\ldots,\sel_{4,i},x_{\perm_{1,i}},\ldots,x_{\perm_{4,i}})=0.\]
\item $\f=\cm(\witf)$.
\end{enumerate}

\subsection{Valid execution trees}\label{sec:validexec}

By an \emph{exeuction tree of length $n$} we mean a tree \tree with $n$ vertices of maximal degree two, whose nodes are
labeled by pairs $(\instapp,\witapp)$.
Let \funcs be a set of elements of \G.
Given such \tree we say it is a \emph{valid execution of length $n$ with function set \funcs and output \recset} if
\begin{enumerate}
 \item For each $\node\in\tree$, its label $(\instapp,\witapp)$ is in \relapp.
    \item For each $\node\in \tree$, let $(\instapp,\witapp)$ be its label. Let 
$\instapp= (\f,\args,\callnum, \f_1,\args_1, \f_2,\args_2,\ops)$. Then
    \begin{itemize}
    \item $\f\in \funcs$.
     \item The number of its children is \callnum.
     \item For $i\in [\callnum]$, let $(\f^i,\args^i,\callnum^i, \f^{i}_{1},\args^i_{1}, \f^i_{2},\args^i_{2},\ops^i)$ denote the first component of $\node$'s $i$'th child's label. Then $\f_i=\f^i$ and  $\args_i=\args^i$.
     \item Let \ops be the multi-set union of $\instapp.\ops$ over all nodes' labels $(\instapp,\witapp)$. Then \ops has output \recset.
     
    \end{itemize}

\end{enumerate}
Given a set of group elements \funcs say it has \emph{Merkle root \root} if \root is the root of a Merkle tree with the elements of  \funcs at the leaves using some pre-determined encoding.

We define a relation \relexec capturing knowledge of an execution of bounded length with a certain output set of records.
$\relexec$ consists of the pairs $(\instexec,\witexec)$
of the form 
\begin{itemize}
 \item $\instexec=(\root,C,\recset)$,
 \item $\witexec=(n,\tree)$,
\end{itemize}
such that $n\leq C$, and  \tree is a valid execution tree of length $n$ with function set \funcs having Merkle root \root, and output set \recset. 

\section{Repeated Computation with Global state}
An RCG relation is defined by a pair of functions $(F,\finpred)$.\\
\noindent
We call $F(Z,W,S,Z^*)\to \set{\acc,\rej}$ the \emph{transition predicate}.

We informally think of 
\begin{itemize}
\item $Z^*$ as the output of $F$ (although the actual output is \set{\acc,\rej}).

\item $Z$ as the public input and $W$ as the private input of $F$.
\item $S$ as the part of the private input that will be used in the final predicate.
\end{itemize}

Let $D_1,D_2$ be the domains of $S,\recset$ respectively. \finpred is a function
$\finpred:D_1^*\times D_2 \to \set{\acc,\rej}$ called the \emph{final predicate}.

The relation $\rel=\rel_{F,\finpred}$ consists of pairs $(\inpF,\witF)$ such that
$\inpF=(\zfin,C,\recset),\witF=(n,z=(z_0,\ldots,z_n),w=(w_1\ldots,w_n),s=(s_1,\ldots,s_n))$ such that
\begin{itemize}
 \item $z_0.\init = \true$.
 \item $z_n=\zfin$.
 \item $n\leq C$.
 \item For each $i\in [n]$, $F(z_{i-1},w_i,s_i,z_i)=\acc$.
 \item $\finpred(z_n,s_1,\ldots,s_n,\recset)=\acc$.
\end{itemize}


We say a \zksnark for \rel is \emph{space-efficient} if given $s$ and streaming access
to $z$ and $w$ \prv requires space $O(|F|+|s|+\log n)$.


\subsection{Valid executions as RCGs}\label{sec:exec->RFC}
We show how to represent checking valid executions as defined in Section \ref{sec:validexec} via RCGs.

Define the function $F(Z,W,Z^*,S)\to \set{\acc,\rej}$ as follows.
\begin{itemize}
 \item $Z=(g,\root,\init)$ where $g$ is a stack of elements of the form $(\f,\args)$, \root is a root of a merkle tree, and \init a boolean.
 \item $Z^*=(g^*,\root^*,\init^*)$ has the same form.
 \item $W=(\path,\instnoops,\witapp)$
 \item $S$ is a set of record operations.
\end{itemize}

\indent Under this notation
$F(Z,W,Z^*,S)=\acc$ if and only if
\begin{enumerate}
\item If $\init=\true$, $g$ contains exactly one element.
 \item Denoting $g[0]=(\f,\args)$, we have $\f=\instnoops.\f$ and $\args=\instnoops.\args$.
 \item Setting $\instapp=(\instnoops,S)$, we have $(\instapp,\witapp)\in \relapp$.
 \item \path is a merkle path from \f to \root.
 \item  $\root=\root^*$.
 \item $g^*$ is the result of popping $(\f,\args)$ from $g$ and then pushing the $\instapp.\callnum$ elements
 $(\instapp.\f_i,\args_i)$ for $i\in [\instapp.\callnum]$.
\end{enumerate}





We define the function \finpred on input $(z_n,s_1,\ldots,s_n,\recset)$ to output \acc if and only if  $z_n.g=\empty$,
each $s_i$ is a well-formed set of record operations, and when defining \ops as the multi-set union of $s_1,\ldots,s_n$ it  has output \recset.


In the lemma below, we denote by \empty the empty stack.


\begin{lemma}\label{lem:execasRCG}
There is an efficiently computable and efficiently invertible map $\phi$ such that the following holds.
Let \funcs be a set of function commitments with Merkle root \root. Fix positive integers $n,C$ with $n\leq C$.
Define $\zfin=(\empty,\root,\false)$. Let \tree be an execution tree of length $n$.

Then  $( (\root,C,\recset),\tree)\in \relexec$ if and only if $((\zfin,C,\recset),\phi(\tree))\in \rel_{F,\finpred}$.

 
\end{lemma}
\begin{proof}
We describe the operation of $\phi$.
Given \tree of length $n$ let $(\instapp_1,\witapp_1),\ldots,(\instapp_{n},\witapp_{n})$ be the labels of its nodes according to 
DFS order.
Define a sequence of stacks $g_0,\ldots,g_n$ according to the sequence of labels.

Namely, $g_0$ is the stack containing only $(\instapp_1.\f,\instapp_1.\args)$. And for each $i\in [n]$, $g_i$ is
the stack obtained by popping $g[0]$ and adding $(\instapp_i.\f_j,\args_j)$ for $j\in [\instapp_i.\callnum]$.

Now, define $z_0=(g_0,\root,\true)$ and for each $i\in [n]$, $z_i=(g_i,\root,\false)$.



We now need to refer to the record operations in each instance separately.
For this purpose,
for each $i\in [n]$, denote $\instapp_i=(\instnoops_i,\ops_i)$.
For each $i\in [n]$, let $\path_i$ be the path from $\instapp_i.\f$ to \root.
Define for each $i\in [n]$, $w_{i}=(\path_i,\instnoops_i,\witapp_i)$, $s_i=\ops_i$.
Finally set $z=(z_0,\ldots,z_n),w=(w_1,\ldots,w_n),s=(s_1,\ldots,s_n)$
 and $\phi(\tree)=(n,z,w,s)$. Given this definition of $\phi$ the statement of the lemma is straightforward to check.
\end{proof}

\subsection{Removing the global state}

\paragraph{Rational Identities:}
Following work on ``log-derivative lookup'' \cite{bplusplus,logup}, we characterize the validity of record operations via rational identites.
\begin{claim}\label{clm:reducetologder}
Assume $\F$ has characteristic larger than $n+1$.
Let \recset be a set of records and $\ops=\sett{(\op_i,v_i,vc_i,c_i)}{i\in [n]}$ be a set of record operations (defining $vc_i=0$ when $\op_i=\add$).
Then \ops has output \recset if and only if the following rational function identities hold:
\begin{enumerate}
 \item \[\sum_{(v,c)\in \recset}\frac{1}{X+vY+c}=\sum_{i\in [n],\op_i=\add}\frac{1}{X+v_iY+c_i}-\sum_{i\in [n]   , \op_i=\del}\frac{1}{X+v_iY+vc_i}.\]
 \item For some $m\in \F^n$,
 we have
 \[\sum_{i\in [n],\op_i=\add}\frac{m_i}{X+v_iY+c_i}=\sum_{i\in [n]   , \op_i=\read}\frac{1}{X+v_iY+vc_i}.\]
 \item \[\sumi{n}\frac{1}{X+c_i}=\sumi{n}\frac{1}{X+i}.\]
\end{enumerate}
\end{claim}
\begin{proof}

We focus on the only if direction. That is, if \ops doesn't have output \recset one of  the three identities should not hold.
 Let $M_{v,c}\defeq \frac{1}{X+vY+c}$. The main fact we use is that the rational functions $\sett{M_{v,c}}{(v,c)\in \F^2}$ are linearly independent.
 Thus, $\sum_{v,c} a_{v,c} M_{v,c} = \sum b_{v,c} M_{v,c}$ implies $a_{v,c}=b_{v,c}$ for each $(v,c)\in \F^2$.
 The event of \ops not having output \recset means one of the following occurs.
 \begin{enumerate}
  \item  The multi-set of counters $\sett{c_i}{i\in [n]}$ doesn't equal \set{1,\ldots,n}. In this case, the LHS of the third identity will not have all one coefficients for the elements \sett{M_{0,c}}{i\in [n]} and so cannot equal the RHS.
  
  Note that when we are not in this case the counter in \ops are all distinct, which we assume for the next cases.
 \item For some $v,vc,c$, $(\del,v,vc,c)\in \ops$ but $(\add,v,vc)\notin \ops$; or for some $v,vc,c_1\neq c_2$, $(\del,v,vc,c_1),(\del,v,vc,c_2)\in \ops$: In the first identity RHS, we will have $M_{v,vc}$ with coefficient in the range  $\set{-1,\ldots,-n}$, while in the LHS it has coefficient one or zero.
 \item \recset is \emph{not} equal to the set $\recset'$ of $(v,c)$ for which $(\add,v,c)\in \ops$ but $(\del,v,c)\notin \ops$. We look at the first identity. $\recset'$ is precisely the set of $(v,c)$ with coefficient one on the RHS, while \recset is the set of $(v,c)$ with coefficient one on the LHS. Hence the second identity cannot hold in this case.
\item For some $v,vc,c$, $(\read,v,vc,c)\in \ops$ but $(\add,v,vc)\notin \ops$: In the second identity RHS $M_{v,c}$ will have a coefficient in the range $\set{1,\ldots,n}$ while in the LHS it has coefficient zero.
 \end{enumerate}
\end{proof}







We reduce the relation $\rel_{F,f}$ from the last section to 
$\rel_{F^*,f^*}$:


Let $F$ denote the function $F(Z,W,Z^*,S)\to \set{\acc,\rej}$ as from Section \ref{sec:exec->RFC}.

Define the function $F^*:(Z,W,Z^*)\to \set{\acc,\rej}$:
\begin{itemize}
 \item $Z=(Z_F,\inchash,\incsum,\alpha,\beta,\epsilon)$.
 \item $Z^*=(Z_F^*,\inchash^*,\incsum^*,\alpha^*,\beta^*,\epsilon^*)$.
 \item $W=(W_F,S_F,M)$
\end{itemize}
\noindent
Under this notation
$F^*(Z,W,Z^*)=\acc$ if and only if
\begin{enumerate}
\item $F(Z_F,W_F,S_F,Z_F^*)=\acc$.

\item Let $S_F=\sett{(\op_i,v_i,vc_i,c_i)}{i\in [m]}$. 
We have $\incsum^*=\incsum+$
\[\sum_{i\in [m];\op_i = \add}\frac{1+ \eps m_i}{\alpha +\beta v_i+\ c_i}-\sum_{i\in [m];\op_i = \read}\frac{ \eps }{\alpha +\beta v_i+vc_i}-\sum_{i\in [m];\op_i = \del}\frac{ 1 }{\alpha +\beta v_i+ vc_i}+ \sumi{m}\frac{\epsilon^2}{\alpha+c_i}.\]
\item $\alpha^*=\alpha, \beta^*=\beta,\epsilon^*=\epsilon$.
\item $\inchash^*=\hash(\inchash,\cm(S_F,M))$ \\
\end{enumerate}

\noindent $\finpred^*(Z,\recset)=\acc$ if and only if
\begin{enumerate}
 \item $\incsum=\sum_{(v,c)\in \recset} \frac{1}{\alpha + \beta v+ c}+\sumi{n}\frac{\epsilon^2}{\alpha+c_i}$
 \item $\hash(\inchash,\recset)=(\alpha,\beta,\epsilon)$
\end{enumerate}


\begin{lemma}
There is an efficiently computable and efficiently invertible map $\varphi$ such that the following holds.
Let \funcs be a set of function commitments with Merkle root \root. Fix positive integers $n,C$ with $n\leq C$.
Fix some $\alpha,\beta,\epsilon\in \F$ and set of records \recset.
Define $\zfin=(\empty,\root,\false), \zfin^*\defeq (\zfin,\inchash,\incsum,\alpha,\beta,\epsilon)$ and set $\inst\defeq (\zfin^*,C,\recset)$. Assume the ZTA for the appropriate family of functions appearing in the proof. 
Suppose efficient \adv outputs \wit such that $(\inst,\wit)\in \rel_{F^*,\finpred^*}$.

Let \ztafuncs be the appropriate family of functions to be defined in the proof.
Assume that \cm is collision resistant and the ZTA holds for $(\ztafuncs,\hash, \cm,n)$
Then e.w.p. \negl, $((\zfin,C,\recset),\varphi(\wit))\in \rel_{F,\finpred}$.
 
\end{lemma}
\begin{proof}
Given a witness $\wit=(z',w')$ with $z'=(z'_0,\ldots,z'_n),w'=(w'_1,\ldots,w'_n)$ output by \adv, denote
$z'_i=(z_{i},\inchash_i,\incsum_i,\alpha_i,\beta_i,\epsilon_i), w'=(w_{i},s_{i},M_i)$.
Define $\witF=\varphi(\wit)$ as $\witF\defeq (z_{0},\ldots,z_{n}),(w_{1},\ldots,w_{n}),(s_{1},\ldots,s_{n})$.
From $(\inst,\wit)\in \rel_{F^*,\finpred^*}$,  we know \witF satisfies the transition constraints, namely for $i\in [n]$,
$F(z_{i-1},w_i,s_i,z_i)=\acc$. We also know that $n\leq C$.
It is left to show that e.w.p. \negl $\finpred(\zfin,\recset)=\acc$.
Sketch:
From $((\zfin^*,C,\recset),\wit)\in \rel_{F^*,\finpred^*}$ we know the equations from Claim \ref{clm:reducetologder} hold
at $\alpha,\beta,\epsilon$. If they don't hold identically for \witF can contradict ZTA.
\end{proof}





\section{Non-interactive folding schemes}
We fix a vector space $K$ over \F, and an $\F$-linear function $\cm:\F^M\to K$,  that will be an implicit parameter in the following definition.
% We'll say a relation \accrel is an \emph{extension} of a relation $\rel\subset D_1\times D_2$, if the domain of its witnesses is also $D_2$
% while the domain of its instances is an extension of $D_1$. 
\begin{dfn}\label{dfn:accschme}
Fix relations \rel and \accrel.  An \emph{\accscheme{\rel}{\accrel}} is a pair of algorithms $(\prv,  \ver)$
such that

\begin{enumerate}
 \item \prv on input $(\insttbase,\inst';\wit,\wit')$ produces a pair $(\instt,\wit^*)$ and  proof \prf .
 \item \ver on input $(\insttbase,\inst',\instt,\prf)$ outputs \acc or \rej such that
%  \item \ver receives as $\inst,\inst'$ as inputs and outputs \acc or \rej at then end.
\begin{enumerate}
 \item \textbf{Completeness:} If $(\insttbase,\wit)\in \accrel, (\inst',\wit')\in \rel$, and $\prv(\insttbase,\inst';\wit,\wit')=(\prf,\instt,\witstar)$ then with probability $1-\negl$,  $(\instt,\witstar)\in \accrel$ and $\ver(\insttbase,\inst',\instt,\prf)=\acc$.
\item \textbf{Knowledge soundness in the Algebraic Group Model:}

For any efficient \adv the probability of the following event is \negl:
\adv outputs $(\inst,\tau),\inst',(\inststar,\tau^*),\wit,\wit',\witstar,\prf$
such that 
\begin{enumerate}
\item $\cm(\wit)=\inst,\cm(\wit')=\inst',\cm(\witstar)=\inststar$, 
\item $\ver(\inst,\inst',\inststar,\prf)=\acc$,
\item $((\inststar,\tau^*),\witstar)\in\accrel$, 
\item $((\inst,\tau),\wit)\notin\accrel$ or $(\inst',\wit')\notin \rel$.
\end{enumerate}

\end{enumerate}
\end{enumerate}
\end{dfn}
\subsection{Relations for folding schemes}
We define a more general satisfiability relation than in \cite{protogal}.
We have as parameters, integers $n,M,d$ and an $\F$-vector space $K$.
We have a
\begin{itemize}
 \item \emph{Constraint function} $f:\F^M\to \F^n$ which is a vector of $n$ degree $d$ polynomials,
\item \emph{Instance predicate} $\predinst:K \to \set{\acc,\rej}$,
\item \emph{Commitment function} $\cm:\F^M \to K$ which is $\F$-linear and assumed
to be collision resistant.
\end{itemize}

Given $(f,\predinst,\cm)$ we define a relation $\rel_{f,\predinst,\cm}$ consisting of all pairs
$(\inst,\wit)$ such that
\begin{itemize}
 \item $f(\wit)=0^n$.
 \item $\predinst(\inst)=\acc$.
 \item $\inst=\cm(\wit)$
\end{itemize}

\paragraph{The relation $\relrand$:}
 For brevity, let $\rel=\rel_{f,\predinst,\cm}$.
  As in \cite{protogal}, we define the ``randomized relaxed'' version of $\rel, \relrand$. First, some required notation.
 Let $t\defeq \log n$. For $i\in [n]$, let $S\subset \set{0,\ldots,t-1}$ be the set such that $i-1=\sumj{S}2^j$. We define the $t$-variate polynomial $\pow_i$ as
 \[\pow_i(X_0,\ldots,X_{t-1}) = \prod_{\ell\in S} X_\ell\]
 Note that if $\betaa=(\beta,\beta^2,\beta^4,\ldots,\beta^{2^{t-1}})$, $\pow_i(\betaa)=\beta^{i-1}$.    
  
  Given the above notation, $\relrand$ consists  of the pairs $( \insttbase,\wit)$ with $\insttbase=(\inst,\betaa,e)$ such that
 \begin{enumerate}
  \item $\inst=\cm(\wit)$.
  \item $\betaa\in \F^t, e\in \F$ and we have 
  \[\sumi{n}\pow_{i}(\betaa) f_i(\wit) = e.\]
 \end{enumerate}
(Here, $f_i$ denotes the $i$'th output coordinate of $f$.) 
\subsection{The \protogal scheme}
Deviating from \cite{protogal}, we explicitly present \protogal as a \emph{non-interactive} folding scheme, for the special case of folding $k=1$ instances.
We define $Z(X)\defeq X\cdot(1-X)$. We assume below \hash is a function mapping arbitrary strings to elements of \Fstar.  \\ \\ \noindent
\underline{$\prv_{PG}(\insttbase=(\inst,\betaa,e),\inst_1;\wit,\wit_1)$:}  
\begin{enumerate}
% \item \ver checks for each $i\in [k]$ that $\inst_i$ is \hash-consistent, and outputs \rej otherwise.
%  \item \ver sends a challenge $\delta \in \F$.
 \item  Compute $\delta=\hash(\insttbase,\inst_1)$. Define $\deltaa\defeq (\delta,\delta^2,\ldots,\delta^{2^{t-1}})\in \F^t$.
 \item\label{step:computeF}  Compute the polynomial 
 \[F(X)\defeq \sumi{n}\pow_i(\betaa+X\deltaa) f_i(\wit).\]
 (Note that $F(0)=\sumi{n} \pow_i(\betaa) f_i(\wit) = e$.)
\item\label{step:sendFcoeffs} Denote the non-constant coefficients of $F$ by $a\defeq (F_1,\ldots,F_{t})$.
\item Compute $\alpha = \hash(\delta,a)$
% \item\label{step:computeFalpha} Note that $F(\alpha)= e+\sumi{t}F_i \alpha^i$.
\item\label{step:computeBetastar} Compute $\betaa^*\in \F^{t}$ where $\betaa^*_i\defeq \betaa_i+\alpha\cdot \deltaa_i$.
\item\label{step:computeG} Define the polynomial $G(X)$ as 
\[G(X)\defeq \sumi{n}\pow_i(\betaa^*) f_i(X\cdot \wit + (1-X)\wit_1).\]
\item Compute the polynomial $K(X)$ such that 
\[G(X)= F(\alpha) X + Z(X) K(X).\]
\item\label{step:sendK} Let $b\defeq (K_0,\ldots,K_{d-2})$ be the coefficients of $K(X)$.
\item Compute $\gamma=\hash(\alpha,b)$.
\item\label{step:compute-estar} Compute 
\[e^* \defeq F(\alpha)\gamma + Z(\gamma)K(\gamma).\]
\end{enumerate}
Finally, output
\begin{itemize}
\item the instance
$\instt=(\inststar,\betaa^*,e^*),$
where \[\inst^*\defeq  \gamma\cdot  \inst + (1-\gamma) \inst_1,\]


\item the witness 
$\witstar\defeq \gamma\cdot \wit +  (1-\gamma)\cdot \wit_1,$
\item and the proof $\prf\defeq (a,b)$.\\
\end{itemize}
\noindent
\underline{$\ver_{PG}(\insttbase,\inst_1, \instt,\pi=(a,b)):$}\noindent
\begin{enumerate}
 \item  Compute $\delta,\alpha,\betaa^*, \gamma$ as in the prover algorithm given $\insttbase,\inst_1,a,b$.

\item  Check that $\instt$ is as computed in the prover algorithm. Output \acc iff this is the case. 
\end{enumerate}



For the knowledge soundness analysis we'll use a variant of the Zero-Testing assumption from \cite{novarecursive}.

\begin{dfn}\label{dfn:ZTA}
Fix $\cm:\F^M\to K$, hash function \hash, and integer $d$. Fix the family of functions \ztafuncs. 
We say the tuple $(D,x,\tau)$ is a \emph{degree $d$-relation for $(\ztafuncs,\hash,\cm)$} if
\begin{enumerate}
 \item $D\in \ztafuncs$.
 \item $f(X)\defeq D(x,\tau)$ is a non-zero element of \polysofdegeq{d}. 
 \item Setting $z\defeq \hash(\cm(x),\tau)$, we have $f(z)=0$.
\end{enumerate}

The Zero-Testing Assumption (ZTA) for $(\ztafuncs,\hash,\cm,d)$ states that for any efficient \adv, the probability  that 
\adv outputs a degree $d$-relation for $(\ztafuncs,\hash,\cm)$ is \negl.
\end{dfn}




\begin{thm}\label{thm:pgsoundness}
Set $d'\defeq \max \set{ n,d}$. Denote  $\cmtwo(\wit_1,\wit_2)\defeq (\cm(\wit_1),\cm(\wit_2))$.
Let \ztafuncs be a family of three functions to be defined in the proof.
Assume that \cm is collision resistant and the ZTA holds for $(\ztafuncs,\hash, \cmtwo,d')$
Then \protogal is a \accscheme{\rel}{\relrand}.
\end{thm}
\begin{proof}
The main thing to prove is knowledge soundness in the Algebraic Group Model.
 Fix any efficient \adv. Let $E$ be the event that \adv outputs
$\insttbase=(\inst,\betaa,e),\inst_1,\instt=(\inststar,\betaa^*,e^*),$ $\wit,\wit_1,\witstar,\prf$ such that 
\begin{enumerate}
\item $\cm(\wit)=\inst,\cm(\wit_1)=\inst_1,\cm(\witstar)=\inststar$. 
\item $\verpg(\insttbase,\inst_1,\instt,\prf)=\acc$ 
\item $(\instt,\witstar)\in\relrand$ 
\item $(\insttbase,\wit)\notin\relrand$ or $(\inst_1,\wit_1)\notin \rel$.
\end{enumerate}
According to Definition \ref{dfn:accschme}, knowledge soundness is equivalent to $E$ having 
probability \negl for any such \adv.
We construct an efficient \advprime that runs \adv, and when $E$ occurs outputs either a collision of 
\cm or a degree $d'$-relation for $(\hash,\cm)$. By the theorem assumption this implies $E$ is contained in two events of
probability \negl, and must have  probability \negl itself.

Assume we are in event $E$.
% Since  $\ver_{PG}(\insttbase,\inst_1,\instt,\prf)=\acc$, we have $\inststar=\gamma \inst +(1-\gamma)\inst_1$.
% And since $(\instt,\witstar)\in \relrand$ we have $\cm(\witstar)=\inststar$.
Using linearity of \cm, when $E$ occurs we have 
\[\cm( \gamma\wit+(1-\gamma)\wit_1)=\gamma \inst +(1-\gamma)\inst_1=\inststar=\cm(\witstar).\]
Thus, if $\witstar \neq \gamma \wit + (1-\gamma)\wit_1$, \advprime can output $(\witstar,\gamma\wit+(1-\gamma)\wit_1)$
as a collision of \cm.
Now assume that $\witstar = \gamma \wit + (1-\gamma)\wit_1$.
Suppose $\prf=(a,b)$, with $a=(a_1,\ldots,a_t),b= (b_0,\ldots,b_{d-2})$.
Define $F_0(X)\defeq e+\sum_{i\in [t]} a_iX^i,K'(X)\defeq \sum_{i=0}^{d-2} b_iX^i$.
Let $\alpha,\beta,\delta,\gamma,\betaa,\deltaa$ be computed as in the prover description given $a,b$.
Define the polynomials
\[F'(X)\defeq F_0(X)-\sum_{i\in [n]} \pow_i(\betaa+X\deltaa) f_i(\wit)\]
\[G'(X)\defeq F_0(\alpha)X+ Z(X)K'(X)-\sum_{i\in [n]}\pow_i( \betaa^*) f_i(X\wit +(1-X)\wit_1)\]

Since $((\inststar,\betaa^*,e^*),\witstar)\in \relrand$ and $\ver_{PG}(\insttbase,\inst',\instt,\prf)=\acc$,
\[G'(\gamma) = F_0(\alpha)\gamma + Z(\gamma)K'(\gamma)- \sum_{i\in [n]} \pow_i(\betaa^*) f_i(\gamma\wit +(1-\gamma)\wit_1)=e^*-\sum_{i\in [n]} \pow_i(\betaa^*) f_i(\witstar)=e^*-e^*=0.\]


Set $x\defeq (\wit,\wit_1)$ and $\tau\defeq (\insttbase,\inst_1,\prf,\alpha,\delta)$.
If $G'\not\equiv 0$, \advprime outputs the degree $d'$-relation $(D_1,x,\tau)$,
where $D_1$ is the function that computes $G'(X)$ according to \perpg given $(x,\tau)$

Assume now that $G'\equiv 0$.

If $(\inst_1,\wit_1)\notin \rel$, using $Z(0)=0$ we have 
\[G'(0)= \sum_{i\in [n]}\pow_i( \betaa^*) f_i(\wit_1)=0\]
Define the polynomial $A(X)\defeq \sumi{n}f_i(\wit_1)\pow_i(\betaa_1+\alpha X,\betaa_2 +\alpha X^2,\ldots,\betaa_t+\alpha X^{2^{t-1}})$.
We have $A(\delta)=0$. But since $(\inst_1,\wit_1)\notin \rel$, $A$ is a combination of the $n$ linearly independent polynomials $\sett{\pow_i(\betaa_1+\alpha X,\betaa_2 +\alpha X^2,\ldots,\betaa_t+\alpha X^{2^{t-1}})}{i\in [n]}$ with at least one non-zero coefficient, and so $A(X)\not\equiv 0$. Hence, setting $D_2$ to be the function that computes $A$ given $(x,\insttbase,\inst_1,\alpha)$, 
\advprime can output the degree $n$ relation $(D_2,x,(\insttbase,\inst_1,\alpha))$.


Now, assume that $(\insttbase,\wit)\notin \relrand$.
As we're still assuming $G'\equiv 0$, we have 
\[G'(1)=F_0(\alpha)-\sumi{n}\pow_i(\betaa^*) f_i(\wit)=0,
\]
But we also have $F'(\alpha)=G'(1)$ and so $F'(\alpha)=0$.
On the other hand
\[F'(0)=e-\sumi{n}\pow_i(\betaa) f_i(\wit)\neq 0\]
Setting $\tau=(\insttbase,\inst_1,\alpha,\delta)$ and $D_3$ to be the function that computes $F'$ given $x,\tau$ we
have that $(D,x,\tau)$ is a degree $\log n$ relation that \advprime can output in this case.
Setting $\ztafuncs=\set{D_1,D_2,D_3}$ we have proven knowledge soundness under the theorem assumptions.
\end{proof}







\subsection{Proving record ops via log-derivative}




\section{On protogalaxy}
\subsection{Introspective constraints}
Constraints $f_i$ on \wit, simply low degree polynomials, but have the ability to refer to
components of $\cm(m_j)$
Function $F$ should have ``introspection'' ability to look at commitments.

commitment function will output two representations of $\cm(w)$ - in \G and in \F and 

or PI will include \F representation. which will then be part of $w$. \V will check representations match.
\subsection{Proving \protogal under zero-testing assumption}
\section{The Algebraic Group Model with recursive extraction}
As in \cite{agm}, we assume when \adv outputs $a\in \G$ it outputs a vector $c\in \F^n$ 
with $<c,\srs>=a$. We fix some mapping $G:\F^4\to \G\cup \set{*}$. $*$ means the input doesn't correspond to \G element. We assume that this is the representation \adv uses for elements of \G.

For our security proof, we require a notion of ``recursive extraction'' used by \cite{novarecursive}:
Specifically, we assume that if $c$ output by \A along with $a$, thought of as $c\in(\F^4)^{n/4}$, contains an element $c_i$ with $G(c_i)=a\in \G$, then \A outputs 
$c'\in \F^n$ with $<c',\srs>=c$. The same holds for $c'$. Thus \A must continue outputting representations
until reaching one where no element correponds to $a\in \G$.


\section{Transforming $F$ into $F'$}
\paragraph{Describing $F^*$}
**public input:**
$z$ - output for $F$
$G$ - global state for $F$
$count$ - counter of IVC step
$h$ - supposed hash of accumulator
**private input:**
$acc$ - current accumulator instance
$acc_{prev}$ - previous accumulator instance
$inst$ - instance (of $F'$) to be accumulated.
$w$ - private input for $F$
$\pi$ - proof for protogalaxy verifier

Set $X:=(z,G,count,h)$, $W:=(acc,acc_{prev}, inst, w, \pi)$

$F'(X,W)=\mathrm{accept}$ if and only if:
\begin{enumerate}
 \item  $hash(acc)=h$.
\item $V_{PG}(acc_{prev}, inst, \pi, acc )= \mathrm{acc}$
\item $inst.h=hash(acc_{prev})$.
\item If $count>0$:
\begin{enumerate}
    \item $inst.G = G$.
    \item $inst.count=count-1$.
    \item $F(false,G, inst.z, w,z)=\mathrm{acc}$
    \end{enumerate}
    
\item If $count=0$:
\begin{enumerate}
    \item $F(true,G, inst.z, w,z)=\mathrm{acc}$

    \end{enumerate}
\end{enumerate}




\section*{Acknowledgements}
\bibliographystyle{alpha}
\bibliography{references}
\end{document}


